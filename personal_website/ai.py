import json

import openai
from flask import Blueprint, flash, render_template, request
from flask_login import current_user, login_required

from . import db
from .models import AiEmail

ai = Blueprint("ai", __name__)

with open("/mnt/sdb3/Code/Projects/personal-website-config.json") as f:
    config = json.load(f)

openai.api_key = config["key"]

conversation = [{"role": "system", "content": "You are a helpful assistant."}]


@ai.route("/ProEmail-AI", methods=["GET", "POST"])
@login_required
def aiemails():
    answer = ""
    htmlAnswer = ""
    if request.method == "POST":
        userPrompt = request.form.get("input")
        if request.form["style"] == "friendly":
            style = "friendly"
        else:
            style = "professional"

        customPrompt = [
            {
                "role": "system",
                "content": f"You are a helpful assistant that writes emails in a {style} style",
            },
            {
                "role": "user",
                "content": f"My name is {current_user.firstName}based on my input, you always write customer focused emails and offer additional assistance or follow-up if needed ",
            },
            {
                "role": "system",
                "content": f"I will always respond with an email that is creative and {style} and the beginning of my emails will always be unique so no one knows that it was generated by an ai",
            },
            {"role": "user", "content": f"{userPrompt}"},
        ]

        if len(userPrompt) < 20:
            flash("Description is too short", category="error")
        else:
            prompt = customPrompt
            model = "gpt-3.5-turbo"
            max_tokens = 500
            response = openai.ChatCompletion.create(
                model=model,
                messages=prompt,
                temperature=0,
                max_tokens=max_tokens,
                top_p=0.7,
                frequency_penalty=0.0,
                presence_penalty=0.0,
            )
            print(response)

            answer = response["choices"][0]["message"]["content"]
            htmlAnswer = "<p>" + answer.replace("\n", "<br>") + "</p>"
            primar = (
                customPrompt[0]["content"]
                + customPrompt[1]["content"]
                + customPrompt[2]["content"]
            )
            tokens = response["usage"]["total_tokens"]
            print("tokens: %s" % (tokens))
            # price is $0.0200  /â€Š1K tokens
            new_email = AiEmail(
                userPrompt=userPrompt,
                initPrompt=primar,
                style=style,
                output=answer,
                tokens=tokens,
                model=model,
                user_id=current_user.id,
            )
            db.session.add(new_email)
            db.session.commit()
    return render_template("ai-emails.html", user=current_user, answer=htmlAnswer)


@ai.route("/gpt-conv")
@login_required
def index():
    return render_template("gptconversation.html", user=current_user)


@ai.route("/AiResponse")
def completion_response():
    global conversation
    user_input = request.args.get("msg")
    conversation.append({"role": "user", "content": user_input})
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=conversation,
        temperature=1,
        max_tokens=1000,
        top_p=0.9,
    )

    conversation.append(
        {"role": "assistant", "content": response["choices"][0]["message"]["content"]}
    )
    finalRes = response["choices"][0]["message"]["content"]
    # print("finalRes: %s" % (finalRes))
    HTMLFinalRes = "<p>" + finalRes.replace("\n", "<br>") + "</p>"
    # print("HTMLFinalRes: %s" % (HTMLFinalRes))
    tokens = response["usage"]["total_tokens"]
    print("tokens: %s" % (tokens))
    return HTMLFinalRes
